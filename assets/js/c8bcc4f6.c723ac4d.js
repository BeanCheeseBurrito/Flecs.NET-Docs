"use strict";(self.webpackChunkflecs_net_docs=self.webpackChunkflecs_net_docs||[]).push([[258],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=i,h=d["".concat(o,".").concat(u)]||d[u]||m[u]||l;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<l;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3137:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>x,contentTitle:()=>E,default:()=>A,frontMatter:()=>N,metadata:()=>I,toc:()=>P});var a=n(7462),i=n(7294),l=n(3905),r=n(6010),s=n(2466),o=n(6550),c=n(1980),p=n(7392),d=n(12);function m(e){return function(e){return i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function u(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??m(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function y(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,c._X)(l),(0,i.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=u(e),[r,s]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[o,c]=y({queryString:n,groupId:a}),[p,m]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,l]=(0,d.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),g=(()=>{const e=o??p;return h({value:e,tabValues:l})?e:null})();(0,i.useLayoutEffect)((()=>{g&&s(g)}),[g]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!h({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),m(e)}),[c,m,l]),tabValues:l}}var k=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function C(e){let{className:t,block:n,selectedValue:l,selectValue:o,tabValues:c}=e;const p=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),m=e=>{const t=e.currentTarget,n=p.indexOf(t),a=c[n].value;a!==l&&(d(t),o(a))},u=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:s}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>p.push(e),onKeyDown:u,onClick:m},s,{className:(0,r.Z)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":l===t})}),n??t)})))}function f(e){let{lazy:t,children:n,selectedValue:a}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function T(e){const t=g(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",b.tabList)},i.createElement(C,(0,a.Z)({},e,t)),i.createElement(f,(0,a.Z)({},e,t)))}function w(e){const t=(0,k.Z)();return i.createElement(T,(0,a.Z)({key:String(t)},e))}const v={tabItem:"tabItem_Ymn6"};function _(e){let{children:t,hidden:n,className:a}=e;return i.createElement("div",{role:"tabpanel",className:(0,r.Z)(v.tabItem,a),hidden:n},t)}const N={sidebar_position:1},E="Quick Start",I={unversionedId:"documentation/quickstart",id:"documentation/quickstart",title:"Quick Start",description:"This document provides a quick overview of the different features and concepts in Flecs with short examples. This is a good resource if you're just getting started or just want to get a better idea of what kind of features are available in Flecs!",source:"@site/docs/documentation/quickstart.md",sourceDirName:"documentation",slug:"/documentation/quickstart",permalink:"/Flecs.NET-Docs/docs/documentation/quickstart",draft:!1,editUrl:"https://github.com/BeanCheeseBurrito/Flecs.NET-Docs/docs/documentation/quickstart.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"documentation",previous:{title:"Quick start",permalink:"/Flecs.NET-Docs/docs/documentation/intro"}},x={},P=[{value:"Nuget",id:"nuget",level:2},{value:"Concepts",id:"concepts",level:2},{value:"World",id:"world",level:3},{value:"Entity",id:"entity",level:3},{value:"Id",id:"id",level:3},{value:"Component",id:"component",level:3},{value:"Tag",id:"tag",level:3},{value:"Pair",id:"pair",level:3},{value:"Hierarchies",id:"hierarchies",level:3},{value:"Instancing",id:"instancing",level:3},{value:"Type",id:"type",level:3},{value:"Singleton",id:"singleton",level:3},{value:"Filter",id:"filter",level:3},{value:"Query",id:"query",level:3},{value:"System",id:"system",level:3},{value:"Pipeline",id:"pipeline",level:3},{value:"Observer",id:"observer",level:3},{value:"Module",id:"module",level:3}],O={toc:P},S="wrapper";function A(e){let{components:t,...i}=e;return(0,l.kt)(S,(0,a.Z)({},O,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"quick-start"},"Quick Start"),(0,l.kt)("p",null,"This document provides a quick overview of the different features and concepts in Flecs with short examples. This is a good resource if you're just getting started or just want to get a better idea of what kind of features are available in Flecs!"),(0,l.kt)("h2",{id:"nuget"},"Nuget"),(0,l.kt)("p",null,"You can download the nuget package and use ",(0,l.kt)("strong",{parentName:"p"},"Flecs.NET")," right away!"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Flecs.NET (Wrapper + bindings + native libraries): ",(0,l.kt)("a",{parentName:"strong",href:"https://www.nuget.org/packages/Flecs.NET.Release/"},"Release")," | ",(0,l.kt)("a",{parentName:"strong",href:"https://www.nuget.org/packages/Flecs.NET.Debug/"},"Debug"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-console"},"dotnet add PROJECT package Flecs.NET.Release --version *-*\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Flecs.NET.Bindings (Bindings + native libraries): ",(0,l.kt)("a",{parentName:"strong",href:"https://www.nuget.org/packages/Flecs.NET.Bindings.Release/"},"Release")," | ",(0,l.kt)("a",{parentName:"strong",href:"https://www.nuget.org/packages/Flecs.NET.Bindings.Debug/"},"Debug"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-console"},"dotnet add PROJECT package Flecs.NET.Bindings.Release --version *-*\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Flecs.NET.Native (Native libraries): ",(0,l.kt)("a",{parentName:"strong",href:"https://www.nuget.org/packages/Flecs.NET.Native.Release/"},"Release")," | ",(0,l.kt)("a",{parentName:"strong",href:"https://www.nuget.org/packages/Flecs.NET.Native.Debug/"},"Debug"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-console"},"dotnet add PROJECT package Flecs.NET.Native.Release --version *-*\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Flecs.NET")," provides both ",(0,l.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Flecs.NET.Release"},"release")," and ",(0,l.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Flecs.NET.Debug"},"debug")," packages for nuget.\nTo include both of them in your project based on your build configuration, use the packages references below. The latest stable or prerelease versions will be added to your project."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<ItemGroup>\n    <PackageReference Include="Flecs.NET.Debug" Version="*-*" Condition="\'$(Configuration)\' == \'Debug\'" />\n    <PackageReference Include="Flecs.NET.Release" Version="*-*" Condition="\'$(Configuration)\' == \'Release\'" />\n</ItemGroup>\n')),(0,l.kt)("h2",{id:"concepts"},"Concepts"),(0,l.kt)("p",null,"This section contains an overview of all the different concepts in Flecs and how they wire together. The sections in the quickstart go over them in more detail and with code examples."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Flecs Overview",src:n(8849).Z,width:"1200",height:"845"})),(0,l.kt)("h3",{id:"world"},"World"),(0,l.kt)("p",null,"The world is the container for all ECS data. It stores the entities and their components, does queries and runs systems. Typically there is only a single world, but there is no limit on the number of worlds an application can create."),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"using Flecs.NET.Core;\n\nusing World world = World.Create();\n\n// Do the ECS stuff\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"flecs::world world;\n\n// Do the ECS stuff\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_world_t *world = ecs_init();\n\n// Do the ECS stuff\n\necs_fini(world);\n")))),(0,l.kt)("h3",{id:"entity"},"Entity"),(0,l.kt)("p",null,'An entity is a unique thing in the world, and is represented by a 64 bit id. Entities can be created and deleted. If an entity is deleted it is no longer considered "alive". A world can contain up to 4 billion(!) alive entities. Entity identifiers contain a few bits that make it possible to check whether an entity is alive or not.'),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity e = world.Entity();\ne.IsAlive(); // true!\n\ne.Destruct();\ne.IsAlive(); // false!\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto e = world.entity();\ne.is_alive(); // true!\n\ne.destruct();\ne.is_alive(); // false!\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_entity_t e = ecs_new_id(world);\necs_is_alive(world, e); // true!\n\necs_delete(world, e);\necs_is_alive(world, e); // false!\n")))),(0,l.kt)("p",null,"Entities can have names which makes it easier to identify them in an application. In C++ and .NET the name can be passed to the constructor. In C a name can be assigned with the ",(0,l.kt)("inlineCode",{parentName:"p"},"ecs_entity_init")," function/",(0,l.kt)("inlineCode",{parentName:"p"},"ecs_entity")," macro. If a name is provided during entity creation time and an entity with that name already exists, the existing entity will be returned."),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'Entity e = world.Entity("Bob");\n\nConsole.WriteLine($"Entity name: {e.Name()}");\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'auto e = world.entity("Bob");\n\nstd::cout << "Entity name: " << e.name() << std::endl;\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},'ecs_entity_t e = ecs_entity(world, { .name = "Bob" });\n\nprintf("Entity name: %s\\n", ecs_get_name(world, e));\n')))),(0,l.kt)("p",null,"Entities can be looked up by name with the ",(0,l.kt)("inlineCode",{parentName:"p"},"Lookup")," function:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'Entity e = world.Lookup("Bob");\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'auto e = world.lookup("Bob");\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},'ecs_entity_t e = ecs_lookup(world, "Bob");\n')))),(0,l.kt)("h3",{id:"id"},"Id"),(0,l.kt)("p",null,'An id is a 64 bit number that can encode anything that can be added to an entity. In flecs this can be either a component, tag or a pair. A component is data that can be added to an entity. A tag is an "empty" component. A pair is a combination of two component/tag ids which is used to encode entity relationships. All entity/component/tag identifiers are valid ids, but not all ids are valid entity identifier.'),(0,l.kt)("p",null,"The following sections describe components, tags and pairs in more detail."),(0,l.kt)("h3",{id:"component"},"Component"),(0,l.kt)("p",null,"A component is a type of which instances can be added and removed to entities. Each component can be added only once to an entity (though not really, see ",(0,l.kt)("a",{parentName:"p",href:"#pair"},"Pair"),"). In C applications components must be registered before use. In C++ and .NET this happens automatically."),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity e = world.Entity();\n\n// Add a component. This creates the component in the ECS storage, but does not\n// assign it with a value.\ne.Add<Velocity>();\n\n// Set the value for the Position & Velocity components. A component will be\n// added if the entity doesn't have it yet.\ne.Set(new Position { X = 10, Y = 20 })\n .Set(new Velocity { X = 1, Y = 2 });\n\n// Get a component\nref readonly Position p = ref e.Get<Position>();\n\n// Remove component\ne.Remove<Position>();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto e = world.entity();\n\n// Add a component. This creates the component in the ECS storage, but does not\n// assign it with a value.\ne.add<Velocity>();\n\n// Set the value for the Position & Velocity components. A component will be\n// added if the entity doesn't have it yet.\ne.set<Position>({10, 20})\n .set<Velocity>({1, 2});\n\n// Get a component\nconst Position *p = e.get<Position>();\n\n// Remove component\ne.remove<Position>();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ECS_COMPONENT(world, Position);\nECS_COMPONENT(world, Velocity);\n\necs_entity_t e = ecs_new_id(world);\n\n// Add a component. This creates the component in the ECS storage, but does not\n// assign it with a value.\necs_add(world, e, Velocity);\n\n// Set the value for the Position & Velocity components. A component will be\n// added if the entity doesn't have it yet.\necs_set(world, e, Position, {10, 20});\necs_set(world, e, Velocity, {1, 2});\n\n// Get a component\nconst Position *p = ecs_get(world, e, Position);\n\n// Remove component\necs_remove(world, e, Position);\n")))),(0,l.kt)("p",null,"Each component is associated by a unique entity identifier by Flecs. This makes it possible to inspect component data, or attach your own data to components. C applications can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"ecs_id")," macro to get the entity id for a component. C++ applications can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"world::entity")," function and .NET applications can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"world.Entity")," function:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity posE = world.Entity<Position>();\nConsole.WriteLine($\"Name: {posE.Name()}); // outputs 'Name: Position'\n\n// It's possible to add components like you would for any entity\nposE.Add<Serializable>();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"flecs::entity pos_e = world.entity<Position>();\nstd::cout << \"Name: \" << pos_e.name() << std::endl;  // outputs 'Name: Position'\n\n// It's possible to add components like you would for any entity\npos_e.add<Serializable>();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ECS_COMPONENT(world, Position);\n\necs_entity_t pos_e = ecs_id(Position);\nprintf(\"Name: %s\\n\", ecs_get_name(world, pos_e)); // outputs 'Name: Position'\n\n// It's possible to add components like you would for any entity\necs_add(world, pos_e, Serializable);\n")))),(0,l.kt)("p",null,"The thing that makes an ordinary entity a component is the ",(0,l.kt)("inlineCode",{parentName:"p"},"EcsComponent")," (or ",(0,l.kt)("inlineCode",{parentName:"p"},"flecs::Component"),", in C++) component. This is a builtin component that tells Flecs how much space is needed to store a component, and can be inspected by applications:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'Entity posE = world.Entity<Position>();\n\nref readonly EcsComponent c = ref posE.Get<EcsComponent>();\nConsole.WriteLine($"Component size: {c.size}");\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'flecs::entity pos_e = world.entity<Position>();\n\nconst EcsComponent *c = pos_e.get<flecs::Component>();\nstd::cout << "Component size: " << c->size << std::endl;\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},'ECS_COMPONENT(world, Position);\n\necs_entity_t pos_e = ecs_id(Position);\n\nconst EcsComponent *c = ecs_get(world, pos_e, EcsComponent);\nprintf("Component size: %u\\n", c->size);\n')))),(0,l.kt)("p",null,"Because components are stored as regular entities, they can in theory also be deleted. To prevent unexpected accidents however, by default components are registered with a tag that prevents them from being deleted. If this tag were to be removed, deleting a component would cause it to be removed from all entities. For more information on these policies, see ",(0,l.kt)("a",{parentName:"p",href:"Relationships.md#cleanup-properties"},"Relationship cleanup properties"),"."),(0,l.kt)("h3",{id:"tag"},"Tag"),(0,l.kt)("p",null,"A tag is a component that does not have any data. In Flecs tags can be either empty types (in C++ and .NET) or regular entities that do not have the ",(0,l.kt)("inlineCode",{parentName:"p"},"EcsComponent")," component (or have an ",(0,l.kt)("inlineCode",{parentName:"p"},"EcsComponent")," component with size 0). Tags can be added & removed using the same APIs as adding & removing components, but because tags have no data, they cannot be assigned a value. Because tags (like components) are regular entities, they can be created & deleted at runtime."),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"// Option 1: create Tag as empty struct\npublic struct Enemy { }\n\n// Create entity, add Enemy tag\nEntity e = world.Entity().Add<Enemy>();\ne.Has<Enemy>(); // true!\n\ne.Remove<Enemy>();\ne.Has<Enemy>(); // false!\n\n\n// Option 2: create Tag as entity\nEntity Enemy = world.Entity();\n\n// Create entity, add Enemy tag\nEntity e = world.Entity().Add(Enemy);\ne.Has(Enemy); // true!\n\ne.Remove(Enemy);\ne.Has(Enemy); // false!\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"// Option 1: create Tag as empty struct\nstruct Enemy { };\n\n// Create entity, add Enemy tag\nauto e = world.entity().add<Enemy>();\ne.has<Enemy>(); // true!\n\ne.remove<Enemy>();\ne.has<Enemy>(); // false!\n\n\n// Option 2: create Tag as entity\nauto Enemy = world.entity();\n\n// Create entity, add Enemy tag\nauto e = world.entity().add(Enemy);\ne.has(Enemy); // true!\n\ne.remove(Enemy);\ne.has(Enemy); // false!\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Create Enemy tag\necs_entity_t Enemy = ecs_new_id(world);\n\n// Create entity, add Enemy tag\necs_entity_t e = ecs_new_id(world);\n\necs_add_id(world, e, Enemy);\necs_has_id(world, e, Enemy); // true!\n\necs_remove_id(world, e, Enemy);\necs_has_id(world, e, Enemy); // false!\n")))),(0,l.kt)("p",null,"Note that both options in the C++ and .NET examples achieve the same effect. The only difference is that in option 1 the tag is fixed at compile time, whereas in option 2 the tag can be created dynamically at runtime."),(0,l.kt)("p",null,"When a tag is deleted, the same rules apply as for components (see ",(0,l.kt)("a",{parentName:"p",href:"Relationships.md#cleanup-properties"},"Relationship cleanup properties"),")."),(0,l.kt)("h3",{id:"pair"},"Pair"),(0,l.kt)("p",null,'A pair is a combination of two entity ids. Pairs can be used to store entity relationships, where the first id represents the relationship kind and the second id represents the relationship target (called "object"). This is best explained by an example:'),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"// Create Likes relationship as empty type (tag)\npublic struct Likes { }\n\n// Create a small graph with two entities that like each other\nEntity Bob = world.Entity();\nEntity Alice = world.Entity();\n\nBob.Add<Likes>(Alice); // Bob likes Alice\nAlice.Add<Likes>(Bob); // Alice likes Bob\nBob.Has<Likes>(Alice); // true!\n\nBob.Remove<Likes>(Alice);\nBob.Has<Likes>(Alice); // false!\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"// Create Likes relationship as empty type (tag)\nstruct Likes { };\n\n// Create a small graph with two entities that like each other\nauto Bob = world.entity();\nauto Alice = world.entity();\n\nBob.add<Likes>(Alice); // Bob likes Alice\nAlice.add<Likes>(Bob); // Alice likes Bob\nBob.has<Likes>(Alice); // true!\n\nBob.remove<Likes>(Alice);\nBob.has<Likes>(Alice); // false!\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Create Likes relationship\necs_entity_t Likes = ecs_new_id(world);\n\n// Create a small graph with two entities that like each other\necs_entity_t Bob = ecs_new_id(world);\necs_entity_t Alice = ecs_new_id(world);\n\necs_add_pair(world, Bob, Likes, Alice); // Bob likes Alice\necs_add_pair(world, Alice, Likes, Bob); // Alice likes Bob\necs_has_pair(world, Bob, Likes, Alice); // true!\n\necs_remove_pair(world, Bob, Likes, Alice);\necs_has_pair(world, Bob, Likes, Alice); // false!\n")))),(0,l.kt)("p",null,"A pair can be encoded in a single 64 bit identifier by using the ",(0,l.kt)("inlineCode",{parentName:"p"},"ecs_pair")," macro in C, or the ",(0,l.kt)("inlineCode",{parentName:"p"},"world.pair")," function in C++ and .NET:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Id id = world.Pair<Likes>(Bob);\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"flecs::id id = world.pair<Likes>(Bob);\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_id_t id = ecs_pair(Likes, Bob);\n")))),(0,l.kt)("p",null,"The following examples show how to get back the elements from a pair:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"if (id.IsPair()) \n{\n    Entity relationship = id.First();\n    Entity target = id.Second();\n}\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"if (id.is_pair()) {\n    auto relationship = id.first();\n    auto target = id.second();\n}\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"if (ecs_id_is_pair(id)) {\n    ecs_entity_t relationship = ecs_pair_first(world, id);\n    ecs_entity_t target = ecs_pair_second(world, id);\n}\n")))),(0,l.kt)("p",null,"A component or tag can be added multiple times to the same entity as long as it is part of a pair, and the pair itself is unique:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Bob.Add(Eats, Apples);\nBob.Add(Eats, Pears);\nBob.Add(Grows, Pears);\n\nBob.Has(Eats, Apples); // true!\nBob.Has(Eats, Pears);  // true!\nBob.Has(Grows, Pears); // true!\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"Bob.add(Eats, Apples);\nBob.add(Eats, Pears);\nBob.add(Grows, Pears);\n\nBob.has(Eats, Apples); // true!\nBob.has(Eats, Pears);  // true!\nBob.has(Grows, Pears); // true!\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_add_pair(world, Bob, Eats, Apples);\necs_add_pair(world, Bob, Eats, Pears);\necs_add_pair(world, Bob, Grows, Pears);\n\necs_has_pair(world, Bob, Eats, Apples); // true!\necs_has_pair(world, Bob, Eats, Pears);  // true!\necs_has_pair(world, Bob, Grows, Pears); // true!\n")))),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"target")," function can be used to get the object for a relationship:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity o = Alice.Target<Likes>(); // Returns Bob\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto o = Alice.target<Likes>(); // Returns Bob\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_entity_t o = ecs_get_target(world, Alice, Likes, 0); // Returns Bob\n")))),(0,l.kt)("p",null,"Entity relationships enable lots of interesting patterns and possibilities. Make sure to check out the ",(0,l.kt)("a",{parentName:"p",href:"Relationships.md"},"Relationships manual"),"."),(0,l.kt)("h3",{id:"hierarchies"},"Hierarchies"),(0,l.kt)("p",null,"Flecs has builtin support for hierarchies with the builtin ",(0,l.kt)("inlineCode",{parentName:"p"},"EcsChildOf")," (or ",(0,l.kt)("inlineCode",{parentName:"p"},"flecs::ChildOf"),", in C++) relationship. A hierarchy can be created with the regular relationship API, or with the ",(0,l.kt)("inlineCode",{parentName:"p"},"child_of"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"ChildOf")," shortcut in C++ and .NET:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity parent = world.Entity();\nEntity child = world.Entity().ChildOf(parent);\n\n// Deleting the parent also deletes its children\nparent.Destruct();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto parent = world.entity();\nauto child = world.entity().child_of(parent);\n\n// Deleting the parent also deletes its children\nparent.destruct();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_entity_t parent = ecs_new_id(world);\n\n// ecs_new_w_pair is the same as ecs_new_id + ecs_add_pair\necs_entity_t child = ecs_new_w_pair(world, EcsChildOf, parent);\n\n// Deleting the parent also deletes its children\necs_delete(world, parent);\n")))),(0,l.kt)("p",null,"When entities have names, they can be used together with hierarchies to generate path names or do relative lookups:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'Entity parent = world.Entity("parent");\nEntity child = world.Entity("child").ChildOf(parent);\nConsole.WriteLine(child.Path());// output: \'parent::child\'\n\nworld.Lookup("parent::child"); // returns child\nparent.Lookup("child"); // returns child\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'auto parent = world.entity("parent");\nauto child = world.entity("child").child_of(parent);\nstd::cout << child.path() << std::endl; // output: \'parent::child\'\n\nworld.lookup("parent::child"); // returns child\nparent.lookup("child"); // returns child\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},'ecs_entity_t parent = ecs_entity(world, {\n    .name = "parent"\n});\n\necs_entity_t child = ecs_entity(world, {\n    .name = "child"\n});\n\necs_add_pair(world, child, EcsChildOf, parent);\n\nchar *path = ecs_get_fullpath(world, child);\nprintf("%s\\n", path); // output: \'parent.child\'\necs_os_free(path);\n\necs_lookup_path(world, 0, "parent.child"); // returns child\necs_lookup_path(world, parent, "child");   // returns child\n')))),(0,l.kt)("p",null,"Queries (see below) can use hierarchies to order data breadth-first, which can come in handy when you're implementing a transform system:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Query q = world.Query(\n    filter: world.FilterBuilder()\n        .Term<Position>()\n        .Term<Position>().Parent().Cascade()\n);\n\nq.Iter((Iter it) =>\n{\n    // Do the thing\n});\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto q = world.query_builder<Position, Position>()\n    .term_at(2).parent().cascade()\n    .build();\n\nq.each([](Position& p, Position& p_parent) {\n    // Do the thing\n});\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_query_t *q = ecs_query_init(world, &(ecs_query_desc_t){\n    .filter.terms = {\n        { ecs_id(Position) },\n        { ecs_id(Position), .src = {\n            .flags = EcsCascade,       // Breadth-first order\n            .trav = EcsChildOf // Use ChildOf relationship for traversal\n        }}\n    }\n});\n\necs_iter_t it = ecs_query_iter(world, q);\nwhile (ecs_query_next(&it)) {\n    Position *p = ecs_field(&it, Position, 1);\n    Position *p_parent = ecs_field(&it, Position, 2);\n    for (int i = 0; i < it.count; i++) {\n        // Do the thing\n    }\n}\n")))),(0,l.kt)("h3",{id:"instancing"},"Instancing"),(0,l.kt)("p",null,"Flecs has builtin support for instancing (sharing a single component with multiple entities) through the builtin ",(0,l.kt)("inlineCode",{parentName:"p"},"EcsIsA")," relationship (",(0,l.kt)("inlineCode",{parentName:"p"},"flecs::IsA")," in C++). An entity with an ",(0,l.kt)("inlineCode",{parentName:"p"},"IsA"),' relationship to a base entity "inherits" all entities from that base:'),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity baseEntity = world.Entity().Set(new Triangle(new(0, 0), new(1, 1), new(-1, -1)));\n\n// Create entity that shares components with base\nEntity e = world.Entity().IsA(baseEntity);\nref readonly Triangle t = ref e.Get<Triangle>(); // gets Triangle from base\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto base = world.entity().set<Triangle>({{0, 0}, {1, 1}, {-1, -1}});\n\n// Create entity that shares components with base\nauto e = world.entity().is_a(base);\nconst Triangle *t = e.get<Triangle>(); // gets Triangle from base\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Shortcut to create entity & set a component\necs_entity_t base = ecs_set(world, 0, Triangle, {{0, 0}, {1, 1}, {-1, -1}});\n\n// Create entity that shares components with base\necs_entity_t e = ecs_new_w_pair(world, EcsIsA, base);\nconst Triangle *t = ecs_get(world, e, Triangle); // gets Triangle from base\n")))),(0,l.kt)("p",null,"Entities can override components from their base:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"// Add private instance of Triangle to e, copy value from base\ne.Add<Triangle>();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"// Add private instance of Triangle to e, copy value from base\ne.add<Triangle>();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Add private instance of Triangle to e, copy value from base\necs_add(world, e, Triangle);\n")))),(0,l.kt)("p",null,"Instancing can be used to build modular prefab hierarchies, as the foundation of a batched renderer with instancing support, or just to reduce memory footprint by sharing common data across entities."),(0,l.kt)("h3",{id:"type"},"Type"),(0,l.kt)("p",null,'The type (often referred to as "archetype") is the list of ids an entity has. Types can be used for introspection which is useful when debugging, or when for example building an entity editor. The most common thing to do with a type is to convert it to text and print it:'),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity e = ecs.Entity()\n    .Add<Position>()\n    .Add<Velocity>();\n\nConsole.WriteLine(e.Type().Str()); // output: 'Position,Velocity'\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto e = ecs.entity()\n    .add<Position>()\n    .add<Velocity>();\n\nstd::cout << e.type().str() << std::endl; // output: 'Position,Velocity'\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ECS_COMPONENT(world, Position);\nECS_COMPONENT(world, Velocity);\n\necs_entity_t e = ecs_new_id(world);\necs_add(world, e, Position);\necs_add(world, e, Velocity);\n\nconst ecs_type_t *type = ecs_get_type(world, e);\nchar *type_str = ecs_type_str(world, type);\nprintf(\"Type: %s\\n\", type_str); // output: 'Position,Velocity'\necs_os_free(type_str);\n")))),(0,l.kt)("p",null,"A type can also be iterated by an application:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"e.Each((Id id) =>\n{\n    if (id == world.Id<Position>())\n        // Found Position component!\n});\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"e.each([&](flecs::id id) {\n    if (id == world.id<Position>()) {\n        // Found Position component!\n    }\n});\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"const ecs_type_t *type = ecs_get_type(world, e);\nfor (int i = 0; i < type->count; i++) {\n    if (type->array[i] == ecs_id(Position)) {\n        // Found Position component!\n    }\n}\n")))),(0,l.kt)("h3",{id:"singleton"},"Singleton"),(0,l.kt)("p",null,"A singleton is a single instance of a component that can be retrieved without an entity. The functions for singletons are very similar to the regular API:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"world.Set(new Gravity { Value = 9.81 });\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"// Set singleton component\nworld.set<Gravity>({ 9.81 });\n\n// Get singleton component\nconst Gravity *g = world.get<Gravity>();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Set singleton component\necs_singleton_set(world, Gravity, { 9.81 });\n\n// Get singleton component\nconst Gravity *g = ecs_singleton_get(world, Gravity);\n")))),(0,l.kt)("p",null,"Singleton components are created by adding the component to its own entity id. The above code examples are shortcuts for these regular API calls:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Entity gravE = world.Entity<Gravity>();\n\ngravE.Set(new Gravity { X = 10, Y = 20 });\n\nref readonly Gravity g = ref gravE.Get<Gravity>();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"flecs::entity grav_e = world.entity<Gravity>();\n\ngrav_e.set<Gravity>({10, 20});\n\nconst Gravity *g = grav_e.get<Gravity>();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_set(world, ecs_id(Gravity), Gravity, {10, 20});\n\nconst Gravity *g = ecs_get(world, ecs_id(Gravity), Gravity);\n")))),(0,l.kt)("p",null,"The following examples show how to query for a singleton component:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"world.Query(\n    filter: world.FilterBuilder()\n        .Term<Velocity>()\n        .Term<Gravity>().Singleton()\n);\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"world.query_builder<Velocity, Gravity>()\n    .term_at(2).singleton()\n    .build();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Create query that matches Gravity as singleton\necs_query_t *q = ecs_query(ecs, {\n    .filter.terms = {\n        // Regular component\n        { .id = ecs_id(Velocity) },\n        // A singleton is a component matched on itself\n        { .id = ecs_id(Gravity), .src.id = ecs_id(Gravity) }\n    }\n});\n\n// Create a system using the query DSL with a singleton:\nECS_SYSTEM(world, ApplyGravity, EcsOnUpdate, Velocity, Gravity($));\n")))),(0,l.kt)("h3",{id:"filter"},"Filter"),(0,l.kt)("p",null,"Filters are a kind of uncached query that are cheap to create. This makes them a good fit for scenarios where an application doesn't know in advance what it has to query for, like when finding the children for a parent. The following example shows a simple filter:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'// Initialize a filter with 2 terms\nFilter f = world.Filter(\n    filter: world.FilterBuilder()\n        .Term<Position>()\n        .Term(EcsChildOf, parent)\n);\n\n// Iterate the filter results. Because entities are grouped by their type there\n// are two loops: an outer loop for the type, and an inner loop for the entities\n// for that type.\nf.Iter((Iter it) =>\n{\n    Column<Position> p = it.Field<Position>(1);\n    foreach (int i in it)\n        Console.WriteLine($"{it.Entity(i).Name()}: ({p[i].X}, {p[i].Y})");\n});\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'// For simple queries the each function can be used\nworld.each([](Position& p, Velocity& v) { // flecs::entity argument is optional\n    p.x += v.x;\n    p.y += v.y;\n});\n\n// More complex filters can first be created, then iterated\nauto f = world.filter_builder<Position>()\n    .term(flecs::ChildOf, parent)\n    .build();\n\n// Option 1: each() function that iterates each entity\nf.each([](flecs::entity e, Position& p) {\n    std::cout << e.name() << ": {" << p.x << ", " << p.y << "}" << std::endl;\n});\n\n// Option 2: iter() function that iterates each archetype\nf.iter([](flecs::iter& it, Position *p) {\n    for (int i : it) {\n        std::cout << it.entity(i).name()\n            << ": {" << p[i].x << ", " << p[i].y << "}" << std::endl;\n    }\n});\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},'// Initialize a filter with 2 terms on the stack\necs_filter_t *f = ecs_filter_init(world, &(ecs_filter_desc_t){\n    .terms = {\n        { ecs_id(Position) },\n        { ecs_pair(EcsChildOf, parent) }\n    }\n});\n\n// Iterate the filter results. Because entities are grouped by their type there\n// are two loops: an outer loop for the type, and an inner loop for the entities\n// for that type.\necs_iter_t it = ecs_filter_iter(world, f);\nwhile (ecs_filter_next(&it)) {\n    // Each type has its own set of component arrays\n    Position *p = ecs_field(&it, Position, 1);\n\n    // Iterate all entities for the type\n    for (int i = 0; i < it.count; i++) {\n        printf("%s: {%f, %f}\\n", ecs_get_name(world, it.entities[i]),\n            p[i].x, p[i].y);\n    }\n}\n\necs_filter_fini(f);\n')))),(0,l.kt)("p",null,"Filters can use operators to exclude components, optionally match components or match one out of a list of components. Additionally filters may contain wildcards for terms which is especially useful when combined with pairs."),(0,l.kt)("p",null,"The following example shows a filter that matches all entities with a parent that do not have ",(0,l.kt)("inlineCode",{parentName:"p"},"Position"),":"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"Filter f = world.Filter(\n    filter: world.FilterBuilder()\n        .Term(EcsChildOf, EcsWildcard)\n        .Term<Position>().Oper(EcsNot)\n);\n\n// Iteration code is the same\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"auto f = world.filter_builder<>()\n    .term(flecs::ChildOf, flecs::Wildcard)\n    .term<Position>().oper(flecs::Not)\n    .build();\n\n// Iteration code is the same\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_filter_t *f = ecs_filter_init(world, &(ecs_filter_desc_t){\n    .terms = {\n        { ecs_pair(EcsChildOf, EcsWildcard) }\n        { ecs_id(Position), .oper = EcsNot },\n    }\n});\n\n// Iteration code is the same\n")))),(0,l.kt)("h3",{id:"query"},"Query"),(0,l.kt)("p",null,"Queries are cached versions of filters. They are slower to create than filters, but much faster to iterate since this just means iterating their cache."),(0,l.kt)("p",null,"The API for queries is similar to filters:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"// Create a query with two terms\nQuery q = world.Query(\n    filter: world.FilterBuilder()\n        .Term<Position>()\n        .Term(EcsChildOf, EcsWildcard)\n);\n\n// Iteration is the same as filters\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"// Create a query with two terms\nauto q = world.query_builder<Position>()\n    .term(flecs::ChildOf, flecs::Wildcard)\n    .build();\n\n// Iteration is the same as filters\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Create a query with 2 terms\necs_query_t *q = ecs_query_init(world, &(ecs_query_desc_t){\n    .filter.terms = {\n        { ecs_id(Position) },\n        { ecs_pair(EcsChildOf, EcsWildcard) }\n    }\n});\n\necs_iter_t it = ecs_query_iter(world, q);\nwhile (ecs_query_next(&it)) {\n    // Same as for filters\n}\n")))),(0,l.kt)("p",null,"When using queries, make sure to reuse a query object instead of creating a new one each time you need it. Query creation is expensive, and many of the performance benefits of queries are lost when they are created in loops."),(0,l.kt)("p",null,"See the ",(0,l.kt)("a",{parentName:"p",href:"Queries.md"},"query manual")," for more details."),(0,l.kt)("h3",{id:"system"},"System"),(0,l.kt)("p",null,"A system is a query combined with a callback. Systems can be either ran manually or ran as part of an ECS-managed main loop (see ",(0,l.kt)("a",{parentName:"p",href:"#pipeline"},"Pipeline"),"). The system API looks similar to queries:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"// Systems are called routines in Flecs.NET\nRoutine moveRoutine = world.Routine(\n    filter: world.FilterBuilder().Term<Position>().Term<Velocity>(),\n    callback: (Iter it) =>\n    {\n        Column<Position> p = it.Field<Position>(1);\n        Column<Velocity> v = it.Field<Velocity>(2);\n\n        foreach (int i in it)\n        {\n            p[i].X += v[i].X * it.DeltaTime();\n            p[i].Y += v[i].Y * it.DeltaTime();\n        }\n    }\n);\n\nmoveRoutine.Run();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"// Use each() function that iterates each individual entity\nauto move_sys = world.system<Position, Velocity>()\n    .iter([](flecs::iter it, Position *p, Velocity *v) {\n        for (int i : it) {\n            p[i].x += v[i].x * it.delta_time();\n            p[i].y += v[i].y * it.delta_time();\n        }\n    });\n\n    // Just like with filters & queries, systems have both the iter() and\n    // each() methods to iterate entities.\n\nmove_sys.run();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Option 1, use the ECS_SYSTEM convenience macro\nECS_SYSTEM(world, Move, 0, Position, Velocity);\necs_run(world, Move, delta_time, NULL); // Run system\n\n// Option 2, use the ecs_system_init function/ecs_system macro\necs_entity_t move_sys = ecs_system(world, {\n    .query.filter.terms = {\n        {ecs_id(Position)},\n        {ecs_id(Velocity)},\n    },\n    .callback = Move\n});\n\necs_run(world, move_sys, delta_time, NULL); // Run system\n\n// The callback code (same for both options)\nvoid Move(ecs_iter_t *it) {\n    Position *p = ecs_field(it, Position, 1);\n    Velocity *v = ecs_field(it, Velocity, 2);\n\n    for (int i = 0; i < it->count; i++) {\n        p[i].x += v[i].x * it->delta_time;\n        p[i].y += v[i].y * it->delta_time;\n    }\n}\n")))),(0,l.kt)("p",null,"Systems are stored as entities with an ",(0,l.kt)("inlineCode",{parentName:"p"},"EcsSystem")," component (",(0,l.kt)("inlineCode",{parentName:"p"},"flecs::System")," in C++), similar to components. That means that an application can use a system as a regular entity:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'Console.WriteLine("Routine: " + moveRoutine.Entity.Name());\nmoveRoutine.Entity.Add(EcsOnUpdate);\nmoveRoutine.Entity.Destruct();\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'std::cout << "System: " << move_sys.name() << std::endl;\nmove_sys.add(flecs::OnUpdate);\nmove_sys.destruct();\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},'printf("System: %s\\n", ecs_get_name(world, move_sys));\necs_add(world, move_sys, EcsOnUpdate);\necs_delete(world, move_sys);\n')))),(0,l.kt)("h3",{id:"pipeline"},"Pipeline"),(0,l.kt)("p",null,'A pipeline is a list of tags that when matched, produces a list of systems to run. These tags are also referred to as a system "phase". Flecs comes with a default pipeline that has the following phases:'),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"EcsOnLoad\nEcsPostLoad\nEcsPreUpdate\nEcsOnUpdate\nEcsOnValidate\nEcsPostUpdate\nEcsPreStore\nEcsOnStore\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"flecs::OnLoad\nflecs::PostLoad\nflecs::PreUpdate\nflecs::OnUpdate\nflecs::OnValidate\nflecs::PostUpdate\nflecs::PreStore\nflecs::OnStore\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"EcsOnLoad\nEcsPostLoad\nEcsPreUpdate\nEcsOnUpdate\nEcsOnValidate\nEcsPostUpdate\nEcsPreStore\nEcsOnStore\n")))),(0,l.kt)("p",null,"When a pipeline is executed, systems are ran in the order of the phases. This makes pipelines and phases the primary mechanism for defining ordering between systems. The following code shows how to assign systems to a pipeline, and how to run the pipeline with the ",(0,l.kt)("inlineCode",{parentName:"p"},"progress()")," function:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'world.Routine(\n    name: "Move",\n    filter: world.FilterBuilder().Term<Position>().Term<Velocity>(),\n    routine: world.RoutineBuilder().Kind(EcsOnUpdate),\n    callback: it => { ... }\n);\n\nworld.Routine(\n    name: "Transform",\n    filter: world.FilterBuilder().Term<Position>().Term<Transform>(),\n    routine: world.RoutineBuilder().Kind(EcsPostUpdate),\n    callback: it => { ... }\n);\n\nworld.Routine(\n    name: "Render",\n    filter: world.FilterBuilder().Term<Transform>().Term<Mesh>(),\n    routine: world.RoutineBuilder().Kind(EcsOnStore),\n    callback: it => { ... }\n);\n\nworld.Progress();\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},'world.system<Position, Velocity>("Move").kind(flecs::OnUpdate).each( ... );\nworld.system<Position, Transform>("Transform").kind(flecs::PostUpdate).each( ... );\nworld.system<Transform, Mesh>("Render").kind(flecs::OnStore).each( ... );\n\nworld.progress();\n'))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity);\nECS_SYSTEM(world, Transform, EcsPostUpdate, Position, Transform);\nECS_SYSTEM(world, Render, EcsOnStore, Transform, Mesh);\n\necs_progress(world, 0); // run systems in default pipeline\n")))),(0,l.kt)("p",null,"Because phases are just tags that are added to systems, applications can use the regular API to add/remove systems to a phase:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"moveRoutine.Entity.Add(EcsOnUpdate);\nmoveRoutine.Entity.Remove(EcsPostUpdate);\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"move_sys.add(flecs::OnUpdate);\nmove_sys.remove(flecs::PostUpdate);\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_remove_id(world, Move, EcsOnUpdate);\necs_add_id(world, Move, EcsPostUpdate);\n")))),(0,l.kt)("p",null,"Inside a phase, systems are guaranteed to be ran in their declaration order."),(0,l.kt)("h3",{id:"observer"},"Observer"),(0,l.kt)("p",null,"Observers are callbacks that are invoked when one or more events matches the query of an observer. Events can be either user defined or builtin. Examples of builtin events are ",(0,l.kt)("inlineCode",{parentName:"p"},"OnAdd"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"OnRemove")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"OnSet"),"."),(0,l.kt)("p",null,"When an observer has a query with more than one component, the observer will not be invoked until the entity for which the event is emitted satisfies the entire query."),(0,l.kt)("p",null,"An example of an observer with two components:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},'world.Observer(\n    name: "OnSetPosition",\n    filter: world.FilterBuilder().Term<Position>().Term<Velocity>(),\n    observer: world.ObserverBuilder().Event(EcsOnSet),\n    callback: it => { ... }\n);\n\nEntity e = world.Entity();\ne.Set(new Position { X = 10, Y = 20 });\ne.Set(new Velocity { X = 1, Y = 2 });\ne.Set(new Position { X = 20, Y = 30 });\n'))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"world.observer<Position, Velocity>(\"OnSetPosition\").event(flecs::OnSet).each( ... );\n\nauto e = ecs.entity();     // Doesn't invoke the observer\ne.set<Position>({10, 20}); // Doesn't invoke the observer\ne.set<Velocity>({1, 2});   // Invokes the observer\ne.set<Position>({20, 30}); // Invokes the observer\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"ecs_observer(world, {\n    .filter.terms = { { ecs_id(Position) }, { ecs_id(Velocity) }},\n    .event = EcsOnSet,\n    .callback = OnSetPosition\n});\n\n// Callback code is same as system\n\necs_entity_t e = ecs_new_id(world);    // Doesn't invoke the observer\necs_set(world, e, Position, {10, 20}); // Doesn't invoke the observer\necs_set(world, e, Velocity, {1, 2});   // Invokes the observer\necs_set(world, e, Position, {20, 40}); // Invokes the observer\n")))),(0,l.kt)("h3",{id:"module"},"Module"),(0,l.kt)("p",null,"A module is a function that imports and organizes components, systems, triggers, observers, prefabs into the world as reusable units of code. A well designed module has no code that directly relies on code of another module, except for components definitions. All module contents are stored as child entities inside the module scope with the ",(0,l.kt)("inlineCode",{parentName:"p"},"ChildOf")," relationship. The following examples show how to define a module in different languages:"),(0,l.kt)(w,{mdxType:"Tabs"},(0,l.kt)(_,{value:"C#",label:"C#",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="C#"',title:'"C#"'},"public struct MyModule : IFlecsModule\n{\n    public void InitModule(ref World world)\n    {\n        world.Module<MyModule>();\n\n        // Define components, systems, triggers, ... as usual. They will be\n        // automatically created inside the scope of the module.\n    }\n};\n\n// Import code\nworld.Import<MyModule>();\n"))),(0,l.kt)(_,{value:"C++",label:"C++",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="C++""',title:'"C++""'},"struct my_module {\n    my_module(flecs::world& world) {\n        world.module<my_module>();\n\n        // Define components, systems, triggers, ... as usual. They will be\n        // automatically created inside the scope of the module.\n    }\n};\n\n// Import code\nworld.import<my_module>();\n"))),(0,l.kt)(_,{value:"C",label:"C",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="C"',title:'"C"'},"// Module header (e.g. MyModule.h)\ntypedef struct {\n    float x;\n    float y;\n} Position;\n\nextern ECS_COMPONENT_DECLARE(Position);\n\n// The import function name has to follow the convention: <ModuleName>Import\nvoid MyModuleImport(ecs_world_t *world);\n\n// Module source (e.g. MyModule.c)\nECS_COMPONENT_DECLARE(Position);\n\nvoid MyModuleImport(ecs_world_t *world) {\n    ECS_MODULE(world, MyModule);\n    ECS_COMPONENT_DEFINE(world, Position);\n}\n\n// Import code\nECS_IMPORT(world, MyModule);\n")))))}A.isMDXComponent=!0},8849:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/flecs-quickstart-overview-595d0d935805b362d07ca7b9166ebaf5.png"}}]);